# RECICLANDO.ME - CLIENTE

## PARTE 1: REGISTRO Y LOGIN/LOGOUT
Aplicación web SPA (Single Page Application) creada con React-Router-DOM y TailwindCSS v3.
---
### 1. CREAR PROYECTO
1. Comandos usados para la instalación:
`npm create vite@latest laravel-api-react` -> `react` -> `javascript`,
`npm install`,
`npm install -D tailwindcss@3 postcss autoprefixer`,
`npx tailwindcss init -p`,
`npm install react-router-dom`
2. Configurar TailwindCSS añadiendo los directorios a tailwind.config.js (podemos omitir .ts y .tsx).
3. Borrar src/index.css. Borrar el contenido y copiar el contenido de [las clases personalizadas usadas para las pruebas iniciales](https://github.com/JonVadar/YouTube_videos/blob/main/tailwind_classes.css) que también contienen las directivas de Tailwind, en src/App.css.
4. En src/App.jsx borramos todos los import excepto el de App.css y borramos el useState y todo el contenido del return, dejando sólo un hola mundo. Además como sólo tenemos una función, borramos el export y en la declaración de la función incluimos export default.
5. En src/main.jsx borramos el import de index.css y el StrictMode.
6. Borrar el directorio src/assets con su contenido.

### 2. COMENZAR A DESARROLLAR EL PROYECTO
1. Levantar la API reciclandome-api abriendo dicho proyecto y ejecutando `php artisan serve`.
2. Configurar Vite con vite.config.js añadiendo el servidor como proxy, con la URL y los headers. Esto reducirá el código cada vez que tengamos que implementar un fetch (sólo habrá que poner api/user, api/posts, etc).
3. En src/App.jsx importar BrowserRouter, Routes y Route de "react-router-dom y en el return anidamos Route (donde definiremos el layout poniendo el path al homepage y el elemento que renderizará) en Routes y en BrowserRouter. Dentro definimos la ruta a Home que será la misma que su padre ('/').
4. En src crear el directorio Pages y dentro los archivos Layout.jsx y Home.jsx
5. En Home.jsx crear la función que devuelva un simple h1 por ahora, y lo mismo en Layout.jsx pero que devuelva un header con un nav con el link a Home (usando Link de react-router-dom) y un main con el Outlet (de react-router-dom también). Importamos ambos elementos en App.jsx. Ejecutamos `npm run dev` para ver la aplicación en el navegador.
    Resumen:
    - En App.jsx tenemos definido el sistema de enrutado.
    - Layout.jsx es la pantalla principal de la aplicación donde se renderizarán los componentes cuando sean llamados a través de la ruta. Por ejemplo a través de la ruta "/" se renderiza el componente Home, que en este punto muestra un h1 con el texto "Coordenadas".
6. En src/Pages crear el directorio Auth con los archivos Register.jsx y Login.jsx dentro. Copiar la función de Home dentro de ambos, cambiar los nombres y los textos del return.
7. En Layout.jsx en el nav bajo el Link crear un div con los dos links a Register y Login, y en App.jsx las rutas a ambos componentes.

### 3. AUTENTICACIÓN
1. Crear el formulario de registro en Register.jsx con Name, Email, Password y Confirm Password. En Email dejamos el type en text para ver el error en el backend. Ponemos también el botón. Crear el hook useState formData con el valor inicial formado por un objeto con name, email, password y password_confirmation con strings vacíos. Crear también la función handleRegister(). En form poner el listener onSubmit que ejecute nuestra función, y en cada input el value con la propiedad de nuestro hook formData y un listener onChange que ejecute una función anónima con el setFormData que ejecute un objeto con un spread de formData y el name del targetValue del event. Probar que el formulario devuelve en consola el objeto que introduzcamos.
    - Recordatorio 1: Aplicamos preventDefault al argumento e (evento) para que al ejecutar el listener onSubmit en el form, dicho formulario no se comporte como por defecto se comportan los formularios.
    - Recordatorio 2: El uso del operador spread (...) aquí es una forma de crear una copia superficial del objeto formData y luego modificar una de sus propiedades. Esto es importante en React porque el estado es inmutable, lo que significa que no debes modificar el estado directamente. En su lugar, debes crear una nueva versión del estado con los cambios que deseas aplicar.
    - [Documentación del hook useState](https://es.react.dev/reference/react/useState#reference)
2. Para poder enviar dicho objeto a nuestra API, en handleSubmit hacemos un fetch al endpoint /register (gracias a la configuración que hicimos en vite.config.js ya se incluyen los headers necesarios y el resto de la URL) y hacemos que la función sea asíncrona (y ponemos el await en la sentencia fetch). En el fetch añadimos como argumento un objeto con el método (post) y el body con formData stringificado. Añadimos también el data con dicho fetch convertido en JSON (con el await, importante) y dicho data es lo que ahora queremos ver en consola (lo ponemos en el console.log). Ahora al pulsar el botón Register, la API nos devuelve en consola los objetos con los respectivos errores que las validaciones envían.
3. Pintar dichos errores para que el usuario pueda verlos. Para ello creamos un useState errors en Register.jsx inicialmente con un objeto vacío, y en caso de que data tenga la propiedad errors (que es un objeto) se actualize con setErrors. Esto lo ejecutamos con una sentencia if-else justo debajo de la línea donde cogemos data (si errors es true, setErrors con el objeto errors, y si no, ejecuta el console.log). Mostrar los errores bajo cada campo de entrada (comprobando antes si hay error y concatenando con &&). Copiar y pegar bajo cada campo de entrada del formulario simplemente cambiando la propiedad (excepto para la confirmación del password, claro).
    - Nota: los valores de los errores están en un array, así que hay que incluir la posición.
4. En el proyecto servidor, `php artisan migrate:fresh` y de vuelta al formulario, registrar un usuario y ver que tenemos en consola un objeto con el usuario y otro objeto con el token. Hay que guardar dicho token en el localStorage, porque si lo guardamos en un estado, se perderá al recargar la página. En Inspeccionar ir a Aplicación>Almacenamiento local>nuestro dominio (localhost por ahora) para ver dónde hay que guardar el par clave-valor, pero hay que comparar esa información con la base de datos en vez del almacenamiento local porque si no, la seguridad sería muy baja. Vamos a solucionar esto.
5. En Register.jsx crear un hook useNavigate para que en el else (si la respuesta de handleRegister es exitosa) al registrarse el usuario, redirija a home ('/'). También aquí en el else guardamos el token en almacenamiento local. Para manejar el estado logueado del usuario vamos a usar React context. Allá vamos.
    - [Artículo sobre el uso del hook useNavigate](https://www-geekster-in.translate.goog/articles/usenavigate-in-react-router-dom/?_x_tr_sl=en&_x_tr_tl=es&_x_tr_hl=es&_x_tr_pto=rq#:~:text=useNavigate%20in%20React%20Router%20v6,and%20enhances%20overall%20developer%20productivity.)
6. En src crear el directorio "Context" y dentro el archivo AppContext.jsx. Dentro usamos createContext() que permite presentar información bajo cierto contexto. Para ver cómo funciona, crear la función AppProvider() que devuelve el objeto contextualizado que hemos creado. Como el value por convención es un objeto, dentro de las llaves ponemos otras llaves con la propiedad name. Anidado dentro de este elemento usamos el prop especial children que viene a decir que esperamos otros componentes dentro de este componente. De esta manera podemos envolver toda la app en ese Provider.
    - [Documentación del hook useContext](https://es.react.dev/reference/react/useContext)
7. En main.jsx anidamos App en nuestro AppProvider. Usando React DevTools inspeccionamos la página usando la pestaña Components para ver el árbol de componentes. Orservar que App está envuelto en Context.Provider en el que al pinchar vemos el value que pusimos al declarar la etiqueta AppContext.Provider. Ahora todos los componentes heredan esa propiedad que pusimos. Vamos a ver cómo acceder a ella.
8. En Home.jsx usamos desestructuración para acceder a la propiedad metiendo el AppContext por parámetro al hook useContext y lo mostramos junto al texto del h1. Ahora al acceder a Home vemos el valor en el texto. Comentar esto en Home porque era sólo para la demostración. Continuemos con el registro.
9. En AppContext.jsx creamos un useState para el token que recoja el valor inicial desde el almacenamiento local. Ahora en la etiqueta AppContent.Provider donde teníamos el value de prueba, ponemos de value token y setToken, exponiendo el token a toda la aplicación.
10. En Register.jsx en el else bajo la línea que guarda el token en local storage, usamos setToken para capturar el token. Ahora a modo de prueba comentamos la línea que redirige a Home y por ejemplo bajo el h1 hacemos que se renderice  el token. Hacemos un registro y se verá en pantalla el token. Verlo también en el almacenamiento local. Comentamos la renderización del token y el token en useContext, y descomentamos el navigate a Home. Sólo era una demostración. Con esto ya tenemos el token en el estado de la aplicación, y también en el almacenamiento local.
    - Nota: No estaba enviando bien el token desde el controlador en el Backend (AuthController.php->función register), y me he vuelto loco para pillar bien el token en el lado cliente (ver también README.md del Backend, parte 2, 1.4).

### 4. AUTORIZACIÓN
1. En el punto actual hemos conseguido **autenticar** al usuario. Ahora lo vamos a **autorizar**. Para ello creamos otro useState "user" en AppContext.jsx con un objeto vacío como estado inicial.
2. Crear también la función asíncrona "getUser()" , y dentro:
    - Un const para la respuesta de un fetch al endpoint `api/user` que nos dará al usuario autenticado. Recordar que esa ruta está protegida por el middleware Sanctum, por tanto requerirá el token, así que incluimos headers con la clave Authorization y de valor un string vacío para ver qué ocurre.
    - Recogemos el dato como JSON como siempre.
    - Lo mostramos en consola.
3. Como queremos que esta función se ejecute siempre que el token se actualice, creamos un hook useEffect que la llame. Dicho hook tendrá como primer argumento una función flecha, y como segundo argumento el hook token (el useState) entre corchetes (este argumento ha de ser un array) de manera que el hook se ejecutará si el hook token cambia de valor. En la función flecha ejecutamos un console.log para observar el funcionamiento. Vemos que ya aparece el mensaje en consola. Ahora si registramos otro usuario, vemos en consola el objeto creado (data) por el fetch de getUser(), además de el mensaje enviado otra vez por el hook useEffect.
    - Nota: Como recordatorio, si el segundo argumento del hook useEffect fuese un array vacío, el useEffect sólo se ejecutaría una vez al ejecutarse la función AppProvider donde se encuentra.
    - [Documentación del hook useEffect](https://es.react.dev/reference/react/useEffect)
4. Evidentemente en vez de un console.log, queremos el useEffect para que ejecute la función getUser(), pero para evitar desperdiciar una llamada a la API cuando el token no exista usamos un if. Ahora tenemos en consola el mensaje 'Unauthenticated' que envía nuestro Backend, y si borramos manualmente el token del almacenamiento local, no recibimos mensaje alguno porque no se ejecuta getUser().
5. Ahora en el header del fetch de getUser() ponemos el token como valor de Authorization, precedido de Bearer. Registramos un usuario para ver el objeto en consola. Comentamos el console.log de getUser() y añadimos que actualize el hook user con data (`setUser(data)`).
6. En el value de la etiqueta AppContext.Provider añadimos user para exponer el dato a toda la aplicación.
7. En Layout.jsx capturamos el hook user (`const {user} = useContext(AppContext);`) y hacemos que el div que muestra los links sea condicional. Se mostrará el nombre de usuario sólo si hay un usuario logueado, y si no, se mostrarán los links Login y Register.
8. Poner en el div del true el mensaje de Welcome Back (nombre) de layout.jsx en un párrafo con estilos.
9. En este punto, aún con un usuario logueado, si escribimos /register en la URL podemos acceder a la página de registro. Para solucionarlo, en App.jsx nos llevamos el estado de user y le asignamos el `useContext(appContext);` para poder encerrar en un ternario las rutas usando user como condición.

### 5. LOGIN
1. Copiar todo el código de Register.jsx y pegarlo en Login.jsx sustituyendo el codigo que contiene.
2. Cambiar el nombre de la función Register por Login. En el hook formData quitar name y password_confirmation. Cambiar el nombre de la función handleRegister por handleLogin, cambiar el endpoint por /api/login y comentar el console.log (ya de paso comentar también el de Register.jsx). En el h1 cambiar el mensaje. En el form cambiar la función. Borrar los div de los inputs de name y confirm password. Cambiar el texto del botón.
3. Borrar el token manualmente del almacenamiento local, porque no puede existir cuando estamos en la página de Login, y recargar la página. Veremos que lo único que ha cambiado es que ya no se ve el nombre del usuario. Esto se debe a que fue un error poner un objeto vacío como estado inicial del hook user en AppContext.jsx. Cambiarlo a null para que user pueda ser false.
4. En Login.jsx en la función handleLogin, comentar la redirección a Home y bajo la declaración de data, hacerle un console.log para hacer la siguiente prueba:
5. Si vamos a Login y pulsamos el botón de Login sin rellenar los campos, recibimos los mensajes de error. Si añadimos un email que no está en la BD nos muestra "The selected email is invalid", lo cual es correcto. Si ponemos un email que sí está, pero la contraseña es incorrecta, recibimos el mensaje "The provided credentials are incorrect", **pero la key es `message`** y en la UI no aparece ese mensaje. Dentro hay otra key, **`errors`**. En este caso en Login.jsx se ejecuta el else, y si miramos el almacenamiento local se ha guardado un token undefined. Para arreglar esto vamos al controlador AuthController.php en la API. En el return donde se envía dicho mensaje (función login()), cambiamos el mensaje por un array "errors" con un elemento con clave "email" y el mensaje de error (como vimos en el mensaje que envió). Ahora al hacer login con un email correcto pero una contraseña incorrecta, aparecerá el mensaje "The provided credentials are incorrect.".
6. En Login.jsx, en handleLogin() volver a descomentar el navigate a Home, y comentar el console.log bajo la declaración de data.
    - Nota: En AuthController.php, tanto en la función login() como en register() estaba devolviendo el token como un objeto. Lo he solucionado aplicándole plainTextToken al token en el return de ambas funciones.
7. Ahora el login funciona, pero si por ejemplo manipulamos el valor del token en almacenamiento local, recibimos un 401 en consola, y sólo vemos el texto welcome back, sin el nombre. Para solucionarlo, en AppContext.jsx en la función getUser() metemos el setUser(data) en un if que se ejecute sólo si la respuesta es ok. Ahora no aparece el welcome back sino los enlaces Login y Register (porque ya no hay user) y si volvemos a poner el valor del token correcto se produce el login correctamente. Ahora vamos a la funcionalidad Logout.

### 6. LOGOUT
1. En Layout.jsx vamos a añadir la funcionalidad de Logout. Bajo la línea que renderiza el mensaje de Welcome back, poner un form, borrar el action y ponerle dentro un botón con el texto Logout. A la etiqueta form ponerle un evento onSubmit que ejecute la función handleLogout.
2. Crear en Layout.jsx la función asíncrona handleLogout con el evento por parámetro:
    - Evitar la recarga (preventDefault()).
    - Crear el response con un fetch al endpoint /api/logout. Recordar que este endpoint está protegido requiriendo un token, así que lo incluimos en la cabecera (headers), y para acceder a él, lo incluimos en el hook useContext declarado arriba en la función Layout().
    - Capturar la respuesta en json con el await como siempre, y mostrarla en consola.
    - En caso de que la respuesta sea ok, queremos resetear el token y el user state, borrar el token del almacenamiento local y redireccionar a Home, porqhe si autenticación debe redireccionarse a Home. Así que promero declaramos el hook useNavigate "navigate", y en la función logout() actualizamos el user y el token con setUser y setToken a null, borramos el elemento del local storage y redirigimos a Home. Ir a AppContext para exponer setUser en el value (es el que faltaba de los 4).
3. Presionamos en Logout y recibimos el mensaje 405 en consola (Method Not Allowed) porque el método no puede ser GET, sino POST. Arreglarlo en el fetch.

## PARTE 2: CRUD (CREATE - READ - UPDATE - DELETE)
La primera funcionalidad va a ser que el usuario pueda realizar un CRUD básico de coordenadas, que se listarán en la pantalla principal. Se podrá acceder a cada punto pero sólo el usuario que haya registrado el punto podrá actualizar sus valores o eliminarlo.
---
### 7. CREAR PUNTO
1. Registrar un nuevo usuario. Una vez estamos logueados con el token,
2. En src/Pages crear la carpeta Posts, y dentro crear Create.jsx. Dentro crear la función principal.
3. En el return de la función poner el título en un h1 y debajo, un form sin action, y dentro un div con un input tipo number con 5 decimales y con placeholder. Debajo del div poner otro div, y dentro otro input igual. Bajo este segundo div, poner un botón con el texto Crear.
4. En Layout.jsx, en la parte del return correspondiente al usuario autenticado, copiar uno de los links y pegarlo bajo la línea que renderiza el welcome back cambiándole el path a /create y poniéndole el texto Nuevo punto.
5. En App.jsx, copiar la ruta al login y pegarla debajo de ésta. Así estará protegida (si user es true, renderiza el componente Create, y si no, Login). Ya podemos ver el link Nuevo punto y pinchar en él.
6. En Create.jsx, crear el hook useState formData cuyo valor inicial será un objeto con las propiedades longitude y latitude con valor 0.
7. Crear la función asíncrona para crear points:
    - preventDefault al evento.
    - console.log de formData.
    - En la etiqueta del form, evento onSubmit que la ejecute.
    - En la etiqueta input la latitud, capturar con value la latitud, y con un listener onChange ejecutar el setter del hook formData (setFormData()). Éste setter acepta por parámetro un objeto con una copia (usando spread) de formData, y el valor de latitude. Luego copiar esas dos líneas (value y onChange) Y pegárselas al longitude cambiando la propiedad en ambas líneas. Ahora al pulsar el botón Crear obtenemos en consola el objeto con los valores iniciales a 0, o lo que introduzcamos.
    - Crear el fetch con el endpoint /api/posts con el método post y el headers con el token que debemos importar con su correspondiente hook useContext(AppContext) arriba del todo de la función principal. Ponerle también body con los datos del form usando JSON.stringify.
    - Como siempre, capturar la respuesta en data con el await y pasarle data al console.log.
8. Ahora al pulsar Crear con los campos vacíos obtenemos los errores de validación correspondientes de nuestra API. Para usarlos, bajo el useState formData crear el useState de errors con un objeto vacío de estado inicial. Dentro de la función handleCreate, ponemos un if que ejecute el setter de errors cuando haya errores, y en el else redirija a Home. Declarar este navigate (el hook useNavigate de siempre) sobre el useContext.
9. Para mostrar los errores, bajo la etiqueta input del title, renderizar los errores usando un ternario para cuando existan. Recordar que errors es un array, así que hay que especificar que queremos renderizar el texto (elemento 0). Copiar esta línea y pegar bajo el textarea cambiando latitude por longitude. Ahora al pulsar Create con los inputs vacíos observamos los correspondientes mensajes de error.
10. Ahora creamos un point y lo vemos en consola. Tenemos los datos del point, y lo guardamos bien en la BD, pero no tenemos el nombre del usuario que lo ha escrito. Para ello hacemos unos cambios en PostController.php. En la función store() tenemos en el return el $point. Lo cambiamos por un array con clave 'point' y valor $point, y añadimos clave 'user' con valor $point->user (usando la relación Eloquent que devuelve el usuario al que pertenece el point). Ahora creamos un point para ver que obtenemos en consola un objeto con dos propiedades (point y user). Hacer este cambio también en los return de show() y update(). Ya podemos comentar el console.log que muestra el point al crearse.

### 7. MOSTRAR TODOS LOS POINTS
1. En Home.jsx, definir la función asíncrona getPoints() que contiene un fetch al endpoint /api/points por GET (no hace falta ponerlo) y data recogiendo la respuesta en JSON. Mostrarla en un console.log.
2. Queremos ejecutar esta función cuando se monte el componente, así que lo hacemos en un useEffect con dos argumentos, el callback y un array vacío. Ir a Home para ver en consola los points que haya en la BD pero sin mostrar los usuarios. Solucionarlo en PointController.php cambiando el return usando el método with con la relación (user) aplicándole latest() (para ordenarlos descendentemente en el tiempo) y luego get(). Ahora vemos que en la respuesta se incluye toda la información del usuario que crea cada point.
3. Para mostrar los points en Home.jsx, crear el hook useState points con un array vacío como estado inicial. Luego el getPoints() dentro de un if para cuando la respuesta sea ok, actualizar el estado de points con los datos de la respuesta (data) y comentar el console.log.
4.  En el return bajo el h1, usando un ternario para cuando haya points (points.length > 0) mapear data para mostrarlos (en un div usando como key el point.id), y si no hay ninguno, mostrar un párrafo diciéndolo. Al mostrarlos usar un h2 para el título, un small para el usuario que lo creó y la fecha de creación usando la clase Date con el método toLocaleTimeString(), y otro párrafo para el body del point.
5. Probar hacer logout, registrar un nuevo usuario y crear un nuevo post. Lo siguiente es crear páginas individuales para cada point.
